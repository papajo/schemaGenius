# Export Options

This document defines the various options and formats available for exporting database schemas generated and refined within the application.

## I. Core Principles for Export

*   **Accuracy:** The exported schema must be a precise and faithful representation of the user-refined schema as it exists within the application's workspace.
*   **Usability:** Exported files should be immediately usable in their respective target environments. For example, SQL scripts should be runnable on the target database, and JSON/XML files should be parsable by standard libraries.
*   **Completeness:** The export should include all relevant schema details, including tables (collections for NoSQL), columns (fields), data types, constraints (primary keys, foreign keys, unique, not null), relationships, and indexes.
*   **Target-System Specificity:** When exporting for a particular database system (e.g., MySQL, PostgreSQL, MongoDB), the output must use the correct DDL syntax, data type names, and conventions specific to that system.

## II. Common Export Configuration

Before initiating an export, users will typically have access to the following configuration options:

*   **Target Database System Selection:** A crucial step where the user selects the intended database system (e.g., MySQL, PostgreSQL, SQLite, MongoDB, or a "Generic" option for system-agnostic formats). This choice significantly influences the syntax, data type mapping, and available features in formats like SQL DDL.
*   **Include Comments (Option):** A checkbox or toggle allowing the user to choose whether to include comments in the generated output (e.g., SQL comments for table and column descriptions, if this metadata was captured during the schema design process).
*   **Drop Existing Objects (Option for SQL):** For SQL DDL exports, users can choose to include `DROP TABLE IF EXISTS <table_name>;` (or similar, depending on the target SQL dialect) statements at the beginning of the script. This facilitates easier re-runnability of the script by first cleaning up any existing versions of the schema objects.

## III. Export Formats

### A. SQL Data Definition Language (DDL) Script (`.sql`)

*   **Purpose:** To provide a runnable script for directly creating the database schema in a relational database management system (RDBMS).
*   **Content:**
    *   `CREATE TABLE` statements for each table defined in the schema.
        *   Column definitions within each table, specifying name, data type (mapped to the target system), `NOT NULL` constraints, `UNIQUE` constraints, and `DEFAULT` values.
        *   Primary key constraints, which can be defined inline with the column definition or as a separate table constraint (e.g., `PRIMARY KEY (id)` or `ALTER TABLE ... ADD CONSTRAINT ... PRIMARY KEY`).
        *   Table-level `CHECK` constraints, if defined and supported by the target RDBMS.
    *   `ALTER TABLE ... ADD CONSTRAINT ... FOREIGN KEY ...` statements for defining foreign key relationships. These are typically placed after all `CREATE TABLE` statements to avoid issues related to the order of table creation.
    *   `CREATE INDEX` statements for all indexes, including those on primary keys, foreign keys (if not automatically created by the RDBMS for PK/FK constraints), and any additional user-defined indexed columns.
    *   (Optional, based on user selection) Comments on tables and columns, using SQL comment syntax (e.g., `-- comment` or `COMMENT ON TABLE ... IS '...'`) if supported by the target database and if comments were part of the schema definition.
*   **Target-Specific Syntax:** The generated DDL will be tailored to the selected target database:
    *   **MySQL:** Use of `AUTO_INCREMENT` for auto-incrementing primary keys, `ENGINE=InnoDB` (or other user-specified engine), backticks for quoting identifiers (e.g., `` `Users` ``).
    *   **PostgreSQL:** Use of `SERIAL`, `BIGSERIAL`, or `GENERATED BY DEFAULT AS IDENTITY` for auto-incrementing keys, standard SQL data types like `TEXT` or `VARCHAR` without explicit length for variable-length strings, double quotes for identifiers if they contain special characters or are case-sensitive (e.g., `"MyTable"`).
    *   Other SQL dialects will be supported by adapting to their specific syntax and type systems as new targets are added.
*   **Structure Example (Conceptual - PostgreSQL):**
    ```sql
    -- Target: PostgreSQL
    -- Exported on: YYYY-MM-DD HH:MM:SS

    -- Optional: Drop existing tables
    -- DROP TABLE IF EXISTS "Orders";
    -- DROP TABLE IF EXISTS "Users";

    CREATE TABLE "Users" (
        "id" SERIAL PRIMARY KEY,
        "username" VARCHAR(255) UNIQUE NOT NULL, -- User's login name
        "email" VARCHAR(255) UNIQUE NOT NULL,    -- User's email address
        "created_at" TIMESTAMP WITHOUT TIME ZONE DEFAULT CURRENT_TIMESTAMP
        -- Table comment: Stores user account information
    );
    -- COMMENT ON TABLE "Users" IS 'Stores user account information'; -- Alternative comment style

    CREATE TABLE "Orders" (
        "id" SERIAL PRIMARY KEY,
        "user_id" INTEGER NOT NULL,
        "order_date" DATE NOT NULL,
        "total_amount" DECIMAL(10, 2),
        CONSTRAINT "fk_orders_user_id" FOREIGN KEY ("user_id") REFERENCES "Users"("id") ON DELETE CASCADE ON UPDATE RESTRICT
    );

    CREATE INDEX "idx_orders_user_id" ON "Orders"("user_id");
    ```

### B. JSON Schema Representation (`.json`)

*   **Purpose:** For programmatic use of the schema, integration with other development or documentation tools, or as an intermediate, system-agnostic representation.
*   **Structure:** A well-defined JSON object that hierarchically represents the entire schema.
*   **Key Elements:**
    *   `schemaName`: (Optional) A name for the schema.
    *   `targetDatabase`: The database system for which this schema was intended or last configured (e.g., "MySQL", "PostgreSQL", "MongoDB", "Generic").
    *   `tables` (Array of table objects for RDBMS) or `collections` (Array of collection objects for MongoDB):
        *   Each `table` / `collection` object contains:
            *   `name`: The name of the table or collection.
            *   `columns` / `fields`: An array of column or field objects. Each object includes:
                *   `name`: Column/field name.
                *   `dataType`: Canonical internal data type or target-specific type (e.g., "INTEGER", "VARCHAR", "ObjectId").
                *   `isPrimaryKey`: Boolean, true if this column is part of the primary key.
                *   `isForeignKey`: Boolean, true if this column is part of a foreign key.
                *   `foreignKeyReference`: If `isForeignKey` is true, an object specifying `{ "referencesTable": "ReferencedTableName", "referencesColumn": "ReferencedColumnName" }`.
                *   `isNullable`: Boolean, true if the column allows NULL values.
                *   `isUnique`: Boolean, true if the column has a unique constraint.
                *   `defaultValue`: The default value for the column, if any.
                *   `maxLength`: For string types, the maximum length.
                *   `precision`, `scale`: For decimal/numeric types.
                *   `comment`: (Optional) A description of the column/field.
            *   `primaryKey`: An object or array defining the primary key columns (e.g., `{ "columns": ["id"], "name": "pk_users" }`).
            *   `foreignKeys`: An array of foreign key constraint objects, each detailing `name`, `columns`, `referencedTable`, `referencedColumns`, `onUpdate`, `onDelete`.
            *   `indexes`: An array of index objects, each specifying `name`, `columns` (array of column names), and `isUnique` (boolean).
            *   `comment`: (Optional) A description of the table/collection.
    *   For MongoDB, the structure would reflect collections, fields (with BSON types), embedded document possibilities, and references (`ObjectId`).
*   **Example Snippet (Generic RDBMS):**
    ```json
    {
      "targetDatabase": "Generic",
      "tables": [
        {
          "name": "Users",
          "columns": [
            { "name": "id", "dataType": "INTEGER", "isPrimaryKey": true, "isNullable": false, "comment": "Unique identifier for the user" },
            { "name": "username", "dataType": "VARCHAR", "maxLength": 255, "isUnique": true, "isNullable": false },
            { "name": "email", "dataType": "VARCHAR", "maxLength": 255, "isUnique": true, "isNullable": false }
          ],
          "primaryKey": { "columns": ["id"], "name": "pk_users" },
          "comment": "Stores user information"
        }
        // ... more tables and relationships
      ]
    }
    ```

### C. XML Schema Representation (`.xml`)

*   **Purpose:** Similar to JSON, for integration with systems or workflows that prefer or require XML.
*   **Structure:** An XML document that mirrors the hierarchical structure of the JSON representation. Tags would correspond to JSON keys.
*   **Example Snippet (Generic RDBMS):**
    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <schema targetDatabase="Generic">
        <tables>
            <table name="Users" comment="Stores user information">
                <columns>
                    <column name="id" dataType="INTEGER" isPrimaryKey="true" isNullable="false" comment="Unique identifier for the user" />
                    <column name="username" dataType="VARCHAR" maxLength="255" isUnique="true" isNullable="false" />
                    <column name="email" dataType="VARCHAR" maxLength="255" isUnique="true" isNullable="false" />
                </columns>
                <primaryKey name="pk_users">
                    <columnRef name="id"/>
                </primaryKey>
            </table>
            <!-- ... more tables and relationships -->
        </tables>
    </schema>
    ```

### D. (Future) ORM Code Generation

*   **Purpose:** To generate boilerplate model code for popular Object-Relational Mappers (ORMs), speeding up application development.
*   **Potential Targets:**
    *   **Python:** SQLAlchemy models, Django models.
    *   **Java:** JPA/Hibernate entities.
    *   **Node.js:** Sequelize models, TypeORM entities.
    *   **Other languages/ORMs:** As demand dictates.
*   **Content:** The output would be source code files (e.g., `.py`, `.java`, `.ts`) containing class definitions. These classes would include fields corresponding to table columns, with data types mapped to ORM-specific types, and decorators or base class inheritances to define primary keys, foreign keys, relationships (one-to-many, many-to-many), and constraints as supported by the ORM.
*   **Complexity:** This is a more complex export option requiring sophisticated templating and mapping logic for each target ORM and language.

## IV. User Interface for Export

The user interface for accessing these export options will be designed as described in the `ui_ux_design.md` document:

*   A dedicated "Export" section, tab, or modal dialog within the application.
*   A dropdown menu for the user to select the `targetDatabase` system. This selection may dynamically update the list of available export formats or options.
*   Checkboxes or toggles for common options like `includeComments` and `dropExistingObjects`.
*   Clearly labeled buttons for each available export format (e.g., "Download SQL DDL", "Download JSON Schema", "Download XML Schema"). Clicking a button will trigger the generation and download of the corresponding file.

This range of export options aims to provide flexibility for users to integrate their designed schemas into various development workflows and database systems.
