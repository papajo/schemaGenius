# backend/app/core/parsing_engine/adapters/mysql_adapter.py

from typing import List, Dict, Any, Set, Optional # Added Set, Optional

# Assuming SUPPORTED_GENERIC_TYPES will be added to intermediate_schema.py
from ..intermediate_schema import SchemaISR, TableISR, ColumnISR, ConstraintDetail #, SUPPORTED_GENERIC_TYPES

# Helper function for type mapping
def _map_generic_type_to_mysql(generic_type: str, column_constraints: List[ConstraintDetail]) -> str:
    """Maps generic ISR types to MySQL specific types, considering constraints for ENUM."""
    # Check for ENUM_TYPE first as it requires constraint details
    # In ISR, an ENUM constraint would be a ConstraintDetail with type "ENUM_VALUES"
    # and a "values" key in its details dictionary.
    if generic_type.upper() == "ENUM_TYPE":
        enum_values_detail = next((c for c in column_constraints if c.type == "ENUM_VALUES"), None)
        if enum_values_detail and isinstance(enum_values_detail.details.get("values"), list):
            enum_vals = enum_values_detail.details["values"]
            if enum_vals: # Ensure there are values
                # Correctly quote enum values for SQL
                formatted_enum_values = ", ".join([f"'{str(val).replace("'", "''")}'" for val in enum_vals])
                return f"ENUM({formatted_enum_values})"
        return "VARCHAR(255)" # Fallback for misconfigured ENUM

    mapping = {
        "STRING": "VARCHAR(255)",
        "TEXT": "TEXT",
        "INTEGER": "INT",
        "BIG_INTEGER": "BIGINT",
        "FLOAT": "FLOAT",
        "DECIMAL": "DECIMAL(10, 2)", # Default precision, can be made configurable via constraint details
        "BOOLEAN": "BOOLEAN",        # Or TINYINT(1)
        "DATE": "DATE",
        "TIME": "TIME",
        "DATETIME": "DATETIME",
        "TIMESTAMP": "TIMESTAMP", # Removed default, should be handled by DEFAULT constraint
        "BLOB": "BLOB",
        "JSON_TYPE": "JSON",
        "UUID_TYPE": "CHAR(36)"    # No native UUID in MySQL before 8.0, often stored as CHAR
    }
    return mapping.get(generic_type.upper(), "VARCHAR(255)") # Default fallback

def convert_isr_to_mysql_ddl(schema_isr: SchemaISR) -> str:
    """
    Converts a SchemaISR object to MySQL DDL (CREATE TABLE statements).
    """
    ddl_statements: List[str] = []

    # Add schema name and version as comments if available
    if schema_isr.schema_name:
        ddl_statements.append(f"-- Schema: {schema_isr.schema_name}")
    if schema_isr.version:
        ddl_statements.append(f"-- Version: {schema_isr.version}")
    ddl_statements.append("-- Generated by SchemaGenius")
    ddl_statements.append("SET FOREIGN_KEY_CHECKS=0; -- Disable temporarily") # Good practice for DDL scripts
    ddl_statements.append("")


    foreign_key_statements: List[str] = [] # Store FKs to add them later

    for table_isr in schema_isr.tables:
        # Add DROP TABLE IF EXISTS statement
        ddl_statements.append(f"DROP TABLE IF EXISTS `{table_isr.name}`;")

        column_definitions: List[str] = []
        table_level_constraints: List[str] = []
        primary_key_col_names: List[str] = []

        for col_isr in table_isr.columns:
            col_def_parts: List[str] = [f"`{col_isr.name}`"]
            col_def_parts.append(_map_generic_type_to_mysql(col_isr.generic_type, col_isr.constraints))

            is_pk_col = False
            is_auto_increment_col = False

            for constraint in col_isr.constraints:
                constraint_type = constraint.type.upper() if constraint.type else ""

                if constraint_type == "PRIMARY_KEY":
                    primary_key_col_names.append(f"`{col_isr.name}`")
                    is_pk_col = True
                elif constraint_type == "NOT_NULL":
                    col_def_parts.append("NOT NULL")
                elif constraint_type == "UNIQUE":
                    col_def_parts.append("UNIQUE")
                elif constraint_type == "DEFAULT":
                    default_value = constraint.details.get("value")
                    if isinstance(default_value, str):
                        # Handle special SQL keywords like CURRENT_TIMESTAMP
                        if default_value.upper() == "CURRENT_TIMESTAMP":
                             col_def_parts.append(f"DEFAULT {default_value.upper()}")
                        else:
                             col_def_parts.append(f"DEFAULT '{default_value.replace("'", "''")}'")
                    elif isinstance(default_value, (int, float)): # Numbers
                        col_def_parts.append(f"DEFAULT {default_value}")
                    # Boolean might need special handling (e.g., TRUE/FALSE vs 1/0)
                    elif isinstance(default_value, bool):
                        col_def_parts.append(f"DEFAULT {'TRUE' if default_value else 'FALSE'}")

                elif constraint_type == "AUTO_INCREMENT":
                    is_auto_increment_col = True # Applied with PK

                elif constraint_type == "FOREIGN_KEY":
                    ref_table = constraint.details.get("references_table")
                    ref_column = constraint.details.get("references_columns") # Assuming list for future composite keys
                    if ref_table and ref_column and isinstance(ref_column, list) and ref_column:
                        fk_name = constraint.details.get("name", f"fk_{table_isr.name}_{col_isr.name}")
                        on_delete = constraint.details.get("on_delete", "NO ACTION") # Common default
                        on_update = constraint.details.get("on_update", "NO ACTION") # Common default
                        # FKs are typically added after table creation or as table-level constraints
                        # For simplicity here, let's assume single column FK for now and add as ALTER TABLE
                        foreign_key_statements.append(
                            f"ALTER TABLE `{table_isr.name}` ADD CONSTRAINT `{fk_name}` FOREIGN KEY (`{col_isr.name}`) "
                            f"REFERENCES `{ref_table}` (`{ref_column[0]}`) ON DELETE {on_delete.upper()} ON UPDATE {on_update.upper()};"
                        )
                # CHECK constraints are parsed but MySQL versions < 8.0.16 ignore them. For >8.0.16, they can be added.
                # For now, we'll skip adding them to the DDL directly in this simplified version.

            if is_pk_col and is_auto_increment_col:
                 col_def_parts.append("AUTO_INCREMENT")

            if col_isr.comment:
                col_def_parts.append(f"COMMENT '{col_isr.comment.replace("'", "''")}'")

            column_definitions.append(" ".join(col_def_parts))

        # Define table-level primary key if any PK columns were identified
        if primary_key_col_names:
            # If only one PK col and it had AUTO_INCREMENT, it's already part of its def
            # Otherwise, define explicitly (handles composite PKs too)
            pk_already_inline = len(primary_key_col_names) == 1 and "AUTO_INCREMENT" in " ".join(c for c in column_definitions if primary_key_col_names[0] in c)
            if not pk_already_inline or len(primary_key_col_names) > 1:
                 table_level_constraints.append(f"PRIMARY KEY ({', '.join(primary_key_col_names)})")

        all_definitions = column_definitions + table_level_constraints
        create_table_statement = f"CREATE TABLE `{table_isr.name}` (\n  " + ",\n  ".join(all_definitions) + "\n)"

        # Add table comment and engine (optional, could be configurable)
        table_options = " ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci"
        if table_isr.comment:
            table_options += f" COMMENT='{table_isr.comment.replace("'", "''")}'"

        create_table_statement += f"{table_options};"
        ddl_statements.append(create_table_statement)
        ddl_statements.append("") # Add a blank line for readability

    # Add foreign key constraints at the end
    if foreign_key_statements:
        ddl_statements.append("-- Foreign Key Constraints")
        ddl_statements.extend(foreign_key_statements)
        ddl_statements.append("")

    ddl_statements.append("SET FOREIGN_KEY_CHECKS=1; -- Re-enable checks")
    return "\n".join(ddl_statements)
