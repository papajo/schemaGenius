# Schema Validation and Error Handling Strategy

## 1. Introduction

### Purpose of Validation
The primary purpose of schema validation within the Automatic Database Schema Generation application is to:
*   Ensure the **correctness** of the generated schema, meaning it is syntactically valid and structurally sound.
*   Promote adherence to database design **best practices**, leading to more efficient and maintainable databases.
*   Verify **compatibility** with the user's chosen target database system, preventing deployment issues.
*   Guide users in creating **robust and efficient** database schemas, even if they are not database experts.

### Goals
The goals of the validation and error handling strategy are to:
*   Provide **clear, concise, and actionable feedback** to users about any issues found.
*   Help users understand the implications of certain design choices.
*   Minimize user frustration by catching errors early in the process.
*   Enable users to confidently generate high-quality database schemas.

## 2. Validation Stages

Validation occurs at multiple stages throughout the user's interaction with the application:

### A. Input Parsing and Initial Validation

This stage focuses on the raw input provided by the user.

*   **SQL Syntax Validation:**
    *   **Description:** Checks if the provided SQL DDL (Data Definition Language) statements are syntactically correct according to standard SQL or a specified dialect.
    *   **Tools:**
        *   Parser-level errors generated by the core parsing engine (e.g., ANTLR-generated parser based on SQL grammars).
        *   Libraries like `sqlparse` in Python might be used for preliminary checks or to identify specific statement types before full parsing.
    *   **Error Reporting:**
        *   Highlight the erroneous line or specific token in the input SQL editor.
        *   Display parser-generated error messages, simplified if possible.
    *   **Example Error:** "Syntax error at line 5, char 10 near 'CREAT TABL users ...': Unexpected token 'TABL'. Did you mean 'TABLE'?"

*   **Code Snippet Validation (Python/Java ORM/JPA):**
    *   **Description:** Checks for syntactically correct Python or Java code. For ORM/JPA inputs, it also verifies the presence of expected structures (e.g., model class definitions, entity annotations).
    *   **Tools:**
        *   Python: `ast` module for syntax checking. Custom logic to identify ORM patterns.
        *   Java: JavaParser (or similar) for syntax checking. Custom logic for JPA annotation patterns.
    *   **Error Reporting:**
        *   Highlight errors within the input code editor.
        *   Report issues like: "Python syntax error: Invalid character in identifier at line X.", "No SQLAlchemy model classes found. Ensure classes inherit from 'db.Model'.", or "Java: Missing '@Entity' annotation for class 'Customer'."
    *   **Example Error:** "Python: IndentationError at line 12. Expected an indented block."

*   **File Format Validation (CSV/JSON):**
    *   **Description:** Ensures that uploaded files adhere to the expected format (e.g., a valid CSV structure, well-formed JSON).
    *   **Tools:** Standard Python library parsers (`csv`, `json`).
    *   **Error Reporting:**
        *   Report errors indicating the location of the issue if possible.
    *   **Example Error:** "Invalid JSON format in 'data.json': Expecting property name enclosed in double quotes at line 15, column 5." or "CSV parsing error in 'products.csv': Inconsistent number of columns at row 23. Expected 5 columns, found 4."

*   **Natural Language Input (Confidence Scoring & Clarification):**
    *   **Description:** While not a strict validation of "correctness," the NLP module should provide feedback on its ability to interpret the input. If confidence is low, or ambiguity is high, it should prompt the user.
    *   **Error Reporting (Feedback/Prompt):**
        *   "The description is a bit vague. Could you try to be more specific about table names and their columns?"
        *   "Based on your description, I've identified potential tables: 'Clients', 'Projects'. And potential fields: 'client_name', 'project_deadline'. Does this look right? You can refine this in the next step."
        *   "Low confidence in extracting relationships. Please ensure you clearly state how tables are linked (e.g., 'A client can have many projects')."

### B. Intermediate Schema Validation (Post-Generation, Pre-Target DB)

After initial parsing and generation of an internal, database-agnostic schema representation, this stage checks for logical and structural issues.

*   **Structural Integrity:**
    *   **Missing Primary Keys:**
        *   Message: "Warning: Table 'Orders' does not have a primary key. It's highly recommended to define one for unique row identification and relationships."
        *   Suggestion: "Consider adding an 'id SERIAL PRIMARY KEY' (PostgreSQL) or 'id INT AUTO_INCREMENT PRIMARY KEY' (MySQL) field."
    *   **Orphaned Foreign Keys:**
        *   Message: "Error: Foreign key 'fk_product_category' in table 'Products' references a non-existent table 'Categories'. Please ensure the 'Categories' table is defined or correct the reference."
        *   Suggestion: "Did you mean to reference table 'ProductCategories'?"
    *   **Inconsistent Relationship Definitions:**
        *   Message: "Error: Relationship from 'OrderItems.product_id' to 'Products.product_code' is invalid because 'Products.product_code' is not a primary or unique key in the 'Products' table."
    *   **Circular Dependencies (Simple Cases):**
        *   Message: "Warning: Tables 'A' and 'B' have foreign keys that reference each other directly. This might be valid but can complicate data insertion. Review if this is intended."

*   **Naming Conventions (Warnings/Suggestions - Configurable):**
    *   **Inconsistent Casing:**
        *   Message: "Warning: Table 'UserDetails' and field 'firstName' use mixed casing. The project's preferred convention is 'snake_case' (e.g., 'user_details', 'first_name')."
    *   **Use of Reserved Keywords (Generic SQL):**
        *   Message: "Warning: Field name 'Order' in table 'Customer' might conflict with SQL reserved keywords. Consider renaming to 'customer_order' or similar."
    *   **Pluralization/Singularization:**
        *   Message: "Suggestion: Table name 'User' (singular) is linked via a one-to-many relationship from 'Posts'. Conventional naming suggests the 'many' side's table be singular ('Post') and the 'one' side plural ('Users'), or consistently singular/plural."
    *   **Special Characters or Spaces:**
        *   Message: "Error: Table name 'Customer Orders' contains a space. Spaces are not allowed in table names. Consider 'customer_orders'."

*   **Data Type Best Practices (Warnings/Suggestions):**
    *   **Large Text Types for Short Strings:**
        *   Message: "Suggestion: Field 'status_code' in table 'Transactions' is of type TEXT. If the values are typically short (e.g., 2-3 characters), consider using VARCHAR(10) for efficiency."
    *   **Storing Numbers as Strings:**
        *   Message: "Warning: Field 'quantity' was inferred as STRING from CSV input, but appears to contain only numeric values. Consider changing to INTEGER or DECIMAL for calculations and data integrity."
    *   **Inappropriate Precision for Numeric Types:**
        *   Message: "Suggestion: Field 'unit_price' of type DECIMAL(10,2) might not be suitable if you need to store prices with more than two decimal places."

*   **Normalization Principles (Advanced - Future Enhancement):**
    *   **Detecting Repeating Groups:**
        *   Message: "Suggestion: Fields 'phone1', 'phone2', 'phone3' in table 'Contacts' represent a repeating group. Consider creating a separate 'PhoneNumbers' table linked to 'Contacts' for better normalization."
    *   **Transitive Dependencies (Potential for 3NF violation):**
        *   Message: "Suggestion: In table 'Orders', if 'customer_city' depends on 'customer_id' (which determines 'customer_city'), and 'customer_id' is not the primary key of 'Orders', 'customer_city' might be better placed in a 'Customers' table."

### C. Target Database Specific Validation (During Export or Preview)

When the user chooses to export the schema for a specific database system (e.g., MySQL, PostgreSQL, MongoDB).

*   **Data Type Compatibility:**
    *   Message (Info/Warning): "Info: The generic type 'DATETIME_WITH_TZ' will be converted to 'TIMESTAMP WITH TIME ZONE' for PostgreSQL."
    *   Message (Error): "Error: Data type 'JSONB' used in table 'AnalyticsEvents' is not directly supported by MySQL 5.7. Consider using TEXT/LONGTEXT or upgrading MySQL. Cannot export."
*   **Identifier Length Limits:**
    *   Message: "Error: Table name 'this_is_an_exceptionally_long_table_name_that_exceeds_limits' (68 chars) is too long for PostgreSQL (max 63 chars). Please shorten it."
*   **Reserved Keywords (Target DB Specific):**
    *   Message: "Error: Field name 'RANGE' in table 'SensorData' is a reserved keyword in PostgreSQL. Please rename it."
*   **Feature Support:**
    *   Message (Warning): "Warning: The 'CHECK (price > 0)' constraint for 'Products' will be included in the DDL for MySQL, but CHECK constraints are only enforced starting from MySQL 8.0.16. If using an older version, this constraint will be ignored by the database."
    *   Message (Info): "Info: For MongoDB export, tables will be represented as collections. Foreign keys will be represented as fields intended for manual/application-level joins (e.g., 'user_id' field in 'posts' collection)."
*   **Collation/Charset Issues:**
    *   Message (Warning): "Warning: No specific character set or collation defined for table 'Comments'. Defaulting to target database's default. Consider specifying if particular settings are needed."

## 3. Error Reporting and Communication

Effective communication of errors is key to a good user experience.

*   **User Interface Integration:**
    *   **Input Phase:**
        *   Real-time highlighting (e.g., red squiggly underlines) of syntax errors in code/text areas.
        *   Error messages displayed directly below or as tooltips near the problematic input field.
        *   A summary panel for multiple errors in large inputs.
    *   **Schema Editor (Visualization Page):**
        *   Visual cues on the schema diagram: Red borders or icons on tables/fields with errors; yellow for warnings.
        *   A dedicated "Validation Issues" panel or tab, listing all current errors and warnings. Each item should be clickable, highlighting the corresponding element in the visual editor and properties panel.
    *   **Export Phase:**
        *   Errors and critical warnings displayed prominently in the export modal/page.
        *   The "Download" or "Generate" button may be disabled until critical errors are resolved.
*   **Clarity of Messages:**
    *   **Plain Language:** Avoid overly technical jargon where possible, or provide brief explanations.
    *   **Specificity:** Clearly state:
        *   **What** the problem is (e.g., "Invalid data type").
        *   **Where** it occurred (e.g., "in table 'Users', field 'email'").
        *   **Why** it's an issue (e.g., "because 'EMAIL_ADDRESS' is not a recognized type for PostgreSQL").
    *   **Constructive Tone:** Frame messages to help the user, not blame them.
*   **Severity Levels:**
    *   **Error (Red):** Critical issues that must be fixed. These typically prevent schema generation, saving (in some cases), or export. (e.g., SQL syntax errors, broken foreign key references to non-existent tables, target DB incompatibilities).
    *   **Warning (Yellow/Orange):** Best practice violations or potential issues that don't necessarily block functionality but are advisable to address. Users might be able to proceed but are cautioned. (e.g., unconventional naming, using TEXT for short strings).
    *   **Suggestion/Info (Blue/Green):** Opportunities for improvement, informational notes about automatic conversions, or confirmations of successful (but perhaps non-obvious) actions. (e.g., "Consider adding an index to 'user_id' for faster lookups.", "DATETIME was converted to TIMESTAMP for PostgreSQL compatibility.").

## 4. Suggestions and Auto-Corrections (Where Applicable)

Proactively helping users fix issues improves the experience.

*   **Contextual Suggestions:**
    *   Alongside error messages, provide one or more potential solutions.
    *   Example Error: "Table 'Products' has no primary key." Suggestion: "Add an 'id INT PRIMARY KEY' field?" or "Select an existing field to be the primary key."
*   **Quick Fixes (Optional, with confirmation):**
    *   For common, unambiguous issues, offer a button to apply a suggested fix.
    *   Example Warning: "Field name 'OrderDate' uses CamelCase. Project convention is snake_case." Quick Fix: "[Rename to 'order_date']". User must click to apply.
*   **NLP Refinement Prompts:**
    *   If NLP input is ambiguous: "I found 'customer' and 'order'. How are they related? (a) A customer has many orders, (b) An order has many customers, (c) Other".
    *   Present interpretations for user confirmation: "I understood this as: Table 'users' (columns: name, email), Table 'posts' (columns: title, content), Relationship: 'users' have many 'posts'. Is this correct?"

## 5. Logging

*   **Backend Logging:**
    *   Anonymously log types of validation errors and warnings encountered by users (without logging the actual user data or schema details unless explicitly for debugging with consent).
    *   This data can be invaluable for identifying:
        *   Common user mistakes or points of confusion.
        *   Areas where the application's parsing, inference, or validation logic can be improved.
        *   The popularity of certain input types or target databases, guiding future development.
*   **User-Facing Activity Log (Optional):**
    *   A panel showing a history of actions, validations, and changes within a session, which might help users retrace steps.

By implementing a comprehensive validation and error handling strategy across these stages, the application can significantly enhance user success and the quality of the generated database schemas.
=======
# Validation and Error Handling

This document specifies the validation and error handling mechanisms for the application, aiming to guide users effectively in creating robust database schemas.

## I. Guiding Principles for Validation and Error Handling

*   **Proactive & Real-time (where possible):** Validate inputs and schema changes as early and as continuously as possible, ideally providing feedback in real-time as the user works.
*   **Clear & Actionable Messages:** Error and warning messages must be easy to understand, clearly explain the nature of the problem, and, where possible, suggest concrete solutions or next steps.
*   **Non-Blocking (for warnings):** Distinguish between critical errors that prevent progression (e.g., inability to generate a valid schema) and warnings that suggest best practices or point out potential issues that don't halt the process.
*   **Contextual:** Display error messages and warnings as close as possible to the source of the problem within the UI (e.g., highlighting the specific table, column, or relationship in the visual editor).
*   **Comprehensive:** Implement validation checks across various stages, from initial input parsing to final schema integrity checks against target database system rules.

## II. Validation Stages and Types

### A. Input Parsing Validation

Validation checks performed as the system initially processes user-provided inputs.

*   **Code Snippets (SQL, Python ORM, Java JPA):**
    *   **Syntax Errors:** Basic syntax validation for the specified language (SQL, Python, Java). Report errors directly from the underlying parser (e.g., "SQLSyntaxErrorException: unexpected token 'CREAT' at line 1, column 1").
    *   **Unrecognized Constructs:** If the code uses highly experimental or unsupported ORM features, or very obscure SQL dialect-specific constructs not yet supported, flag these as "Unsupported Feature" or "Partial Support."
*   **Natural Language Descriptions:**
    *   **Ambiguity Detection:** Flag phrases that are too vague or could be interpreted in multiple ways (e.g., Input: "Item details"; Warning: "Phrase 'Item details' is ambiguous. Please specify which details (e.g., 'Item has a name, description, and price')."). Prompt the user for clarification or offer interpretations.
    *   **Low Confidence Extractions:** If the NLP model's confidence for an extracted entity, attribute, or relationship is below a certain threshold, highlight it for user review and confirmation (e.g., "Warning: Low confidence identifying 'status' as an attribute of 'Order'. Please confirm.").
*   **File Uploads (CSV, JSON):**
    *   **Unsupported File Types:** Reject files that are not in the supported formats (e.g., CSV, JSON). Error: "Unsupported file type: '.xlsx'. Please upload a CSV or JSON file."
    *   **Malformed Files:** Report errors if a CSV file is improperly formatted (e.g., inconsistent column counts in rows without quoting) or if a JSON file is syntactically invalid. Error: "Invalid JSON format: Unexpected token ',' at position 54."
    *   **Inconsistent Data (Warnings):** For CSV/JSON, if a column is inferred as Integer but contains many non-numeric values, issue a warning. Warning: "Column 'Age' in 'employees.csv' inferred as Integer, but contains non-numeric values (e.g., 'N/A', 'Unknown'). This may cause data type issues."
    *   **Missing Headers (CSV):** If headers are expected (default or user-specified) but not found in a CSV file, prompt the user. Warning: "CSV file 'data.csv' appears to be missing a header row. Please specify if headers are present or proceed with auto-generated column names."

### B. Intermediate Representation (IR) Validation

Checks performed after initial parsing, on the structured data before full schema generation.

*   **Orphaned Elements:** Check for attributes or relationships that are defined but do not link to any recognized entity (e.g., an attribute `color` was extracted but not associated with any table). Warning: "Extracted attribute 'color' is not associated with any entity. Please assign it or remove it."
*   **Conflicting Information:** If different input sources (e.g., a SQL snippet and an NLP description) define the same entity or attribute with conflicting properties (e.g., different data types for the same column), flag this for user resolution. Warning: "Conflict for 'User.email': SQL defines as VARCHAR(100), NLP suggests it could be TEXT. Please resolve."

### C. Schema Generation & Refinement Validation (Most Critical)

Checks performed during and after the user edits the schema in the visual editor.

*   **Naming Conventions:**
    *   **Invalid Characters:** Check for table and column names containing characters not allowed by SQL standards or the specific target database (e.g., spaces, special symbols unless quoted appropriately). Error: "Invalid character ' ' in table name 'Order Details'. Consider using 'Order_Details'."
    *   **Reserved Keywords:** Warn if names match SQL reserved keywords or keywords specific to the target database. Warning: "Column name 'Order' in table 'Customer' is a reserved keyword in SQL. Consider renaming to 'Order_Name' or similar."
    *   **Uniqueness:** Ensure table names are unique within the schema and column names are unique within their respective tables. Error: "Duplicate table name 'Products'. Table names must be unique."
*   **Primary Keys (PKs):**
    *   **Missing PKs:** Warn if a table lacks a primary key. This can be a configurable setting, as some advanced scenarios might allow this. Warning: "Table 'Audit_Log' does not have a primary key. Consider adding one for optimal performance and data integrity."
    *   **Multiple PKs:** Error if more than one primary key is explicitly defined for a single table (auto-generated composite PKs for join tables are an exception and valid). Error: "Table 'User_Roles' has multiple primary keys defined. A table can have only one primary key."
*   **Foreign Keys (FKs):**
    *   **Referential Integrity:**
        *   Error: "Foreign key 'FK_Order_Customer' in table 'Orders' references non-existent table 'Customers'." (if 'Customers' table was renamed or deleted).
        *   Error: "Foreign key 'FK_Order_Details_Product' references non-existent column 'product_id_typo' in table 'Products'. Did you mean 'product_id'?"
        *   Error: "Data type mismatch for foreign key 'FK_Item_Supplier'. Column 'Items.supplier_id' (INT) does not match referenced column 'Suppliers.supplier_key' (VARCHAR)."
    *   **Circular Dependencies:** Detect direct A->B and B->A FK relationships that might cause issues with data insertion or DDL generation in some RDBMS. Warning: "Circular dependency detected: 'TableA' references 'TableB' and 'TableB' references 'TableA'. This might require deferred constraints or careful data loading strategies."
*   **Data Types:**
    *   **Unsupported Types:** If a data type was specified (e.g., manually entered) that isn't valid for the selected target database system. Error: "Data type 'NUMBERZ' for column 'quantity' in table 'Inventory' is not a valid type for PostgreSQL."
    *   **Incompatible Constraints:** E.g., a `TEXT` or `BLOB` type column marked as `UNIQUE` (possible in some DBs but often very inefficient or with limitations; issue a warning). Warning: "Column 'description' (TEXT) in table 'Documents' is marked UNIQUE. This can lead to performance issues. Consider if this is necessary."
*   **Relationships:**
    *   **Incomplete Relationship Definition:** A relationship is visually drawn or defined but is missing source or target columns. Error: "Incomplete relationship: Please specify source and target columns for the relationship between 'Users' and 'Profiles'."
*   **Database Specific Rules:**
    *   **Length Limits:** Check for table, column, or index names exceeding the maximum length allowed by the target database. Error: "Table name 'a_very_long_table_name_that_exceeds_the_limit' is too long for MySQL (max 64 characters)."
    *   Validate against other specific limitations or features of the selected target (MySQL, PostgreSQL, MongoDB, etc.).

### D. Best Practice Checks (Warnings)

These are suggestions rather than strict errors, aimed at improving schema quality.

*   **Normalization Suggestions (Future Advanced Feature):**
    *   Detecting repeating groups of columns (e.g., `phone1`, `phone2`, `phone3`) that could indicate a need for a separate related table. Warning: "Columns 'phone1, phone2' in 'Contacts' suggest a repeating group. Consider creating a separate 'PhoneNumbers' table."
    *   Identifying potential transitive dependencies.
*   **Overly Large Number of Columns:** Warn if a table has an excessive number of columns (e.g., >50), which might indicate poor design. Warning: "Table 'LegacyData' has 75 columns. Consider if this table could be split for better organization."
*   **Use of Generic Data Types:** Warn when overly generic data types are used where more specific ones might be better (e.g., using `VARCHAR(MAX)` or `TEXT` for fields that are known to be short, like a status flag). Warning: "Column 'status' in 'Tasks' uses VARCHAR(255). If values are short (e.g., 'open', 'closed'), consider a shorter VARCHAR or an ENUM type."
*   **Missing Indexes on Foreign Keys:** Warn if foreign key columns are not indexed, as this can impact join performance. (Note: Many modern RDBMS automatically create indexes on FKs, but it's a good check). Warning: "Column 'user_id' in table 'Posts' is a foreign key but is not indexed. Consider adding an index to improve query performance."

## III. Error Message Presentation

How errors and warnings are communicated to the user.

*   **UI Integration:**
    *   **Visual Schema Editor:** Problematic elements (tables, columns, relationships) are visually highlighted (e.g., with red borders, icons, or different coloring). Hovering over these elements with the mouse cursor reveals a tooltip with the specific error message.
    *   **Properties Panel:** When a table, column, or relationship is selected, any errors or warnings relevant to that specific element are displayed directly within its properties panel.
    *   **Global "Issues" List/Panel:** A dedicated, collapsib_le area in the UI (e.g., a sidebar or bottom panel) that lists all current errors and warnings across the entire schema.
        *   Each item in the list should be clickable, which will navigate the user to and highlight the problematic element in the schema editor.
        *   Error messages should be concise but provide enough detail for understanding.
        *   Consider including unique error codes for easy reference (e.g., "E1023", "W2001"), which can be useful for documentation or support inquiries.
*   **Message Structure (Example):**
    *   **Severity:** [ERROR] / [WARNING]
    *   **Location:** (e.g., "Table 'Users', Column 'email_address'")
    *   **Problem:** (e.g., "Data type mismatch in foreign key relationship.")
    *   **Suggestion:** (e.g., "Ensure 'Orders.user_id' (currently INT) and 'Users.id' (currently STRING) have compatible data types, e.g., both INT.")

## IV. User Correction Flow

1.  User performs an action (e.g., types an input, changes a data type, adds a relationship, modifies a name).
2.  The system validates the input or the change, either in real-time or upon an explicit "validate" action.
3.  If an error or warning is detected:
    *   It is displayed immediately in context (e.g., highlighting the field or schema element) and/or added to the global "Issues" panel.
    *   The problematic part of the schema might be visually marked (e.g., red border).
4.  The user reviews the error message(s) and the provided suggestions.
5.  The user makes corrections based on the feedback (e.g., changes a data type, renames a column, completes a relationship definition).
6.  The system re-validates (often automatically upon change). The error or warning message disappears if the issue is resolved.

## V. Logging

*   **Backend Logging:** The backend application should log significant validation failures, especially those that might indicate bugs or edge cases in the parsing or schema generation logic. These logs should include relevant context.
*   **User-Facing Error Logging (Optional Telemetry):** If telemetry is implemented, user-facing errors (and potentially warnings) can be logged (anonymously, with user consent) to help identify common points of confusion or areas where the application's guidance can be improved.

This comprehensive approach to validation and error handling aims to make the schema design process a helpful and guided experience, rather than a frustrating trial-and-error exercise.
