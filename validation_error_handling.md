# Schema Validation and Error Handling Strategy

## 1. Introduction

### Purpose of Validation
The primary purpose of schema validation within the Automatic Database Schema Generation application is to:
*   Ensure the **correctness** of the generated schema, meaning it is syntactically valid and structurally sound.
*   Promote adherence to database design **best practices**, leading to more efficient and maintainable databases.
*   Verify **compatibility** with the user's chosen target database system, preventing deployment issues.
*   Guide users in creating **robust and efficient** database schemas, even if they are not database experts.

### Goals
The goals of the validation and error handling strategy are to:
*   Provide **clear, concise, and actionable feedback** to users about any issues found.
*   Help users understand the implications of certain design choices.
*   Minimize user frustration by catching errors early in the process.
*   Enable users to confidently generate high-quality database schemas.

## 2. Validation Stages

Validation occurs at multiple stages throughout the user's interaction with the application:

### A. Input Parsing and Initial Validation

This stage focuses on the raw input provided by the user.

*   **SQL Syntax Validation:**
    *   **Description:** Checks if the provided SQL DDL (Data Definition Language) statements are syntactically correct according to standard SQL or a specified dialect.
    *   **Tools:**
        *   Parser-level errors generated by the core parsing engine (e.g., ANTLR-generated parser based on SQL grammars).
        *   Libraries like `sqlparse` in Python might be used for preliminary checks or to identify specific statement types before full parsing.
    *   **Error Reporting:**
        *   Highlight the erroneous line or specific token in the input SQL editor.
        *   Display parser-generated error messages, simplified if possible.
    *   **Example Error:** "Syntax error at line 5, char 10 near 'CREAT TABL users ...': Unexpected token 'TABL'. Did you mean 'TABLE'?"

*   **Code Snippet Validation (Python/Java ORM/JPA):**
    *   **Description:** Checks for syntactically correct Python or Java code. For ORM/JPA inputs, it also verifies the presence of expected structures (e.g., model class definitions, entity annotations).
    *   **Tools:**
        *   Python: `ast` module for syntax checking. Custom logic to identify ORM patterns.
        *   Java: JavaParser (or similar) for syntax checking. Custom logic for JPA annotation patterns.
    *   **Error Reporting:**
        *   Highlight errors within the input code editor.
        *   Report issues like: "Python syntax error: Invalid character in identifier at line X.", "No SQLAlchemy model classes found. Ensure classes inherit from 'db.Model'.", or "Java: Missing '@Entity' annotation for class 'Customer'."
    *   **Example Error:** "Python: IndentationError at line 12. Expected an indented block."

*   **File Format Validation (CSV/JSON):**
    *   **Description:** Ensures that uploaded files adhere to the expected format (e.g., a valid CSV structure, well-formed JSON).
    *   **Tools:** Standard Python library parsers (`csv`, `json`).
    *   **Error Reporting:**
        *   Report errors indicating the location of the issue if possible.
    *   **Example Error:** "Invalid JSON format in 'data.json': Expecting property name enclosed in double quotes at line 15, column 5." or "CSV parsing error in 'products.csv': Inconsistent number of columns at row 23. Expected 5 columns, found 4."

*   **Natural Language Input (Confidence Scoring & Clarification):**
    *   **Description:** While not a strict validation of "correctness," the NLP module should provide feedback on its ability to interpret the input. If confidence is low, or ambiguity is high, it should prompt the user.
    *   **Error Reporting (Feedback/Prompt):**
        *   "The description is a bit vague. Could you try to be more specific about table names and their columns?"
        *   "Based on your description, I've identified potential tables: 'Clients', 'Projects'. And potential fields: 'client_name', 'project_deadline'. Does this look right? You can refine this in the next step."
        *   "Low confidence in extracting relationships. Please ensure you clearly state how tables are linked (e.g., 'A client can have many projects')."

### B. Intermediate Schema Validation (Post-Generation, Pre-Target DB)

After initial parsing and generation of an internal, database-agnostic schema representation, this stage checks for logical and structural issues.

*   **Structural Integrity:**
    *   **Missing Primary Keys:**
        *   Message: "Warning: Table 'Orders' does not have a primary key. It's highly recommended to define one for unique row identification and relationships."
        *   Suggestion: "Consider adding an 'id SERIAL PRIMARY KEY' (PostgreSQL) or 'id INT AUTO_INCREMENT PRIMARY KEY' (MySQL) field."
    *   **Orphaned Foreign Keys:**
        *   Message: "Error: Foreign key 'fk_product_category' in table 'Products' references a non-existent table 'Categories'. Please ensure the 'Categories' table is defined or correct the reference."
        *   Suggestion: "Did you mean to reference table 'ProductCategories'?"
    *   **Inconsistent Relationship Definitions:**
        *   Message: "Error: Relationship from 'OrderItems.product_id' to 'Products.product_code' is invalid because 'Products.product_code' is not a primary or unique key in the 'Products' table."
    *   **Circular Dependencies (Simple Cases):**
        *   Message: "Warning: Tables 'A' and 'B' have foreign keys that reference each other directly. This might be valid but can complicate data insertion. Review if this is intended."

*   **Naming Conventions (Warnings/Suggestions - Configurable):**
    *   **Inconsistent Casing:**
        *   Message: "Warning: Table 'UserDetails' and field 'firstName' use mixed casing. The project's preferred convention is 'snake_case' (e.g., 'user_details', 'first_name')."
    *   **Use of Reserved Keywords (Generic SQL):**
        *   Message: "Warning: Field name 'Order' in table 'Customer' might conflict with SQL reserved keywords. Consider renaming to 'customer_order' or similar."
    *   **Pluralization/Singularization:**
        *   Message: "Suggestion: Table name 'User' (singular) is linked via a one-to-many relationship from 'Posts'. Conventional naming suggests the 'many' side's table be singular ('Post') and the 'one' side plural ('Users'), or consistently singular/plural."
    *   **Special Characters or Spaces:**
        *   Message: "Error: Table name 'Customer Orders' contains a space. Spaces are not allowed in table names. Consider 'customer_orders'."

*   **Data Type Best Practices (Warnings/Suggestions):**
    *   **Large Text Types for Short Strings:**
        *   Message: "Suggestion: Field 'status_code' in table 'Transactions' is of type TEXT. If the values are typically short (e.g., 2-3 characters), consider using VARCHAR(10) for efficiency."
    *   **Storing Numbers as Strings:**
        *   Message: "Warning: Field 'quantity' was inferred as STRING from CSV input, but appears to contain only numeric values. Consider changing to INTEGER or DECIMAL for calculations and data integrity."
    *   **Inappropriate Precision for Numeric Types:**
        *   Message: "Suggestion: Field 'unit_price' of type DECIMAL(10,2) might not be suitable if you need to store prices with more than two decimal places."

*   **Normalization Principles (Advanced - Future Enhancement):**
    *   **Detecting Repeating Groups:**
        *   Message: "Suggestion: Fields 'phone1', 'phone2', 'phone3' in table 'Contacts' represent a repeating group. Consider creating a separate 'PhoneNumbers' table linked to 'Contacts' for better normalization."
    *   **Transitive Dependencies (Potential for 3NF violation):**
        *   Message: "Suggestion: In table 'Orders', if 'customer_city' depends on 'customer_id' (which determines 'customer_city'), and 'customer_id' is not the primary key of 'Orders', 'customer_city' might be better placed in a 'Customers' table."

### C. Target Database Specific Validation (During Export or Preview)

When the user chooses to export the schema for a specific database system (e.g., MySQL, PostgreSQL, MongoDB).

*   **Data Type Compatibility:**
    *   Message (Info/Warning): "Info: The generic type 'DATETIME_WITH_TZ' will be converted to 'TIMESTAMP WITH TIME ZONE' for PostgreSQL."
    *   Message (Error): "Error: Data type 'JSONB' used in table 'AnalyticsEvents' is not directly supported by MySQL 5.7. Consider using TEXT/LONGTEXT or upgrading MySQL. Cannot export."
*   **Identifier Length Limits:**
    *   Message: "Error: Table name 'this_is_an_exceptionally_long_table_name_that_exceeds_limits' (68 chars) is too long for PostgreSQL (max 63 chars). Please shorten it."
*   **Reserved Keywords (Target DB Specific):**
    *   Message: "Error: Field name 'RANGE' in table 'SensorData' is a reserved keyword in PostgreSQL. Please rename it."
*   **Feature Support:**
    *   Message (Warning): "Warning: The 'CHECK (price > 0)' constraint for 'Products' will be included in the DDL for MySQL, but CHECK constraints are only enforced starting from MySQL 8.0.16. If using an older version, this constraint will be ignored by the database."
    *   Message (Info): "Info: For MongoDB export, tables will be represented as collections. Foreign keys will be represented as fields intended for manual/application-level joins (e.g., 'user_id' field in 'posts' collection)."
*   **Collation/Charset Issues:**
    *   Message (Warning): "Warning: No specific character set or collation defined for table 'Comments'. Defaulting to target database's default. Consider specifying if particular settings are needed."

## 3. Error Reporting and Communication

Effective communication of errors is key to a good user experience.

*   **User Interface Integration:**
    *   **Input Phase:**
        *   Real-time highlighting (e.g., red squiggly underlines) of syntax errors in code/text areas.
        *   Error messages displayed directly below or as tooltips near the problematic input field.
        *   A summary panel for multiple errors in large inputs.
    *   **Schema Editor (Visualization Page):**
        *   Visual cues on the schema diagram: Red borders or icons on tables/fields with errors; yellow for warnings.
        *   A dedicated "Validation Issues" panel or tab, listing all current errors and warnings. Each item should be clickable, highlighting the corresponding element in the visual editor and properties panel.
    *   **Export Phase:**
        *   Errors and critical warnings displayed prominently in the export modal/page.
        *   The "Download" or "Generate" button may be disabled until critical errors are resolved.
*   **Clarity of Messages:**
    *   **Plain Language:** Avoid overly technical jargon where possible, or provide brief explanations.
    *   **Specificity:** Clearly state:
        *   **What** the problem is (e.g., "Invalid data type").
        *   **Where** it occurred (e.g., "in table 'Users', field 'email'").
        *   **Why** it's an issue (e.g., "because 'EMAIL_ADDRESS' is not a recognized type for PostgreSQL").
    *   **Constructive Tone:** Frame messages to help the user, not blame them.
*   **Severity Levels:**
    *   **Error (Red):** Critical issues that must be fixed. These typically prevent schema generation, saving (in some cases), or export. (e.g., SQL syntax errors, broken foreign key references to non-existent tables, target DB incompatibilities).
    *   **Warning (Yellow/Orange):** Best practice violations or potential issues that don't necessarily block functionality but are advisable to address. Users might be able to proceed but are cautioned. (e.g., unconventional naming, using TEXT for short strings).
    *   **Suggestion/Info (Blue/Green):** Opportunities for improvement, informational notes about automatic conversions, or confirmations of successful (but perhaps non-obvious) actions. (e.g., "Consider adding an index to 'user_id' for faster lookups.", "DATETIME was converted to TIMESTAMP for PostgreSQL compatibility.").

## 4. Suggestions and Auto-Corrections (Where Applicable)

Proactively helping users fix issues improves the experience.

*   **Contextual Suggestions:**
    *   Alongside error messages, provide one or more potential solutions.
    *   Example Error: "Table 'Products' has no primary key." Suggestion: "Add an 'id INT PRIMARY KEY' field?" or "Select an existing field to be the primary key."
*   **Quick Fixes (Optional, with confirmation):**
    *   For common, unambiguous issues, offer a button to apply a suggested fix.
    *   Example Warning: "Field name 'OrderDate' uses CamelCase. Project convention is snake_case." Quick Fix: "[Rename to 'order_date']". User must click to apply.
*   **NLP Refinement Prompts:**
    *   If NLP input is ambiguous: "I found 'customer' and 'order'. How are they related? (a) A customer has many orders, (b) An order has many customers, (c) Other".
    *   Present interpretations for user confirmation: "I understood this as: Table 'users' (columns: name, email), Table 'posts' (columns: title, content), Relationship: 'users' have many 'posts'. Is this correct?"

## 5. Logging

*   **Backend Logging:**
    *   Anonymously log types of validation errors and warnings encountered by users (without logging the actual user data or schema details unless explicitly for debugging with consent).
    *   This data can be invaluable for identifying:
        *   Common user mistakes or points of confusion.
        *   Areas where the application's parsing, inference, or validation logic can be improved.
        *   The popularity of certain input types or target databases, guiding future development.
*   **User-Facing Activity Log (Optional):**
    *   A panel showing a history of actions, validations, and changes within a session, which might help users retrace steps.

By implementing a comprehensive validation and error handling strategy across these stages, the application can significantly enhance user success and the quality of the generated database schemas.
